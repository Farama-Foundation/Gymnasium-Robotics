__author__ = "Feng Gu"
__email__ = "contact@fenggu.me"

"""
   isort:skip_file
"""

import os
import re

from tqdm import tqdm
from itertools import chain

import gymnasium as gym

from importlib import import_module
from utils import trim


pattern = re.compile(r"(?<!^)(?=[A-Z])")

readme_path = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
    "README.md",
)

fetch_path = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
    "gymnasium_robotics",
    "envs",
    "fetch",
)

hand_path = os.path.join(
    os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
    "gymnasium_robotics",
    "envs",
    "hand",
)

output_path = os.path.join(
    os.path.dirname(os.path.dirname(__file__)),
    "envs",
)


# regex to find the class name
class_p = re.compile(r"class\s([\w]+)\(.*")


# write to file
def generate(name, docstring, type):
    snake_env_name = pattern.sub(" ", name).lower()
    title_env_name = snake_env_name.replace("_", " ").title()
    output_file_path = os.path.join(output_path, type, name + ".md")
    front_matter = f"""---
autogenerated:
title: {title_env_name}
---
"""
    title = f"# {title_env_name}"
    gif = (
        "```{figure} "
        + f"""/_static/videos/{type}/{name}.gif
:alt: {title_env_name}
:width: 200px
```
"""
    )

    if docstring is None:
        docstring = "No information provided"
    all_text = f"""{front_matter}
{title}

{gif}

{docstring}
                """

    with open(output_file_path, "w") as f:
        f.write(all_text)
        f.close()


# TODO: rewrite this
# generate markdown for envs
for (root, dirs, file) in tqdm(chain(os.walk(fetch_path), os.walk(hand_path))):
    for f in file:
        # skip __init__.py and __pycache__
        if not f.endswith(".py") or f.startswith("__"):
            continue
        else:
            env_type = "fetch" if "fetch" in root else "hand"
            curr_path = os.path.join(root, f)
            curr_file = open(curr_path)
            lines = curr_file.readlines()
            docstrings = {}
            docstring = ""
            curr_class = ""
            match = False

            for line in lines:
                if line.strip() == "":
                    trimmed = "\n"
                # remove leading whitespace
                else:
                    trimmed = line.lstrip()

                if trimmed.startswith("class"):
                    class_name = re.search(class_p, trimmed).group(1)
                    # ignore Py classes and remove the "Mujoco" suffix
                    if "Py" not in class_name:
                        class_name = class_name[:-3]
                        if class_name.startswith("Mujoco"):
                            curr_class = class_name[6:]
                            if "TouchSensors" in curr_class:
                                env_type = "hand_touch"

                if trimmed.startswith('"""'):
                    match = not match

                # if we are in a docstring
                if match:
                    if trimmed.startswith('"""'):
                        trimmed = trimmed[3:]
                    docstring += trimmed
                # populating the dict
                else:
                    if len(docstring) > 0:
                        if len(curr_class) > 0:
                            docstrings[curr_class] = docstring
                        docstring = ""
                        curr_class = ""

            # write to file
            for name, docstring in docstrings.items():
                generate(name, docstring, env_type)


# REWRITE: generate md's for new environments that don't belong to Fetch or Shadow Hand
# TODO: use same format for Fetch and Shadow Hand
# The environment entrypoints have the following standard: `gymnasium_robotics.envs.env_type.env_name:EnvName`
all_envs = [
    env_spec
    for env_spec in gym.registry.values()
    if env_spec.entry_point.startswith("gymnasium_robotics.envs")
    and "Mujoco"
    not in env_spec.entry_point  # Exclude Fetch and Shadow Hand environments
]

# Keep latest version of environments
filtered_envs_by_name = {}
for env_spec in all_envs:
    if env_spec.name not in filtered_envs_by_name:
        filtered_envs_by_name[env_spec.name] = env_spec
    elif filtered_envs_by_name[env_spec.name].version < env_spec.version:
        filtered_envs_by_name[env_spec.name] = env_spec

# Extract non-repeated entrypoints of environments
entry_points = {env_spec.entry_point for env_spec in filtered_envs_by_name.values()}

for entry_point in tqdm(entry_points):
    split_module_class = entry_point.split(":")
    module = split_module_class[0]
    env_class = split_module_class[1]
    docstring = getattr(import_module(module), env_class).__doc__
    docstring = trim(docstring)

    split_entrypoint = module.split(".")
    title_env_name = split_entrypoint[-1].replace("_", " ").title()

    if len(split_entrypoint) == 4:
        env_type = split_entrypoint[-2]
        env_name = split_entrypoint[-1]

    if len(split_entrypoint) == 3:
        env_type = split_entrypoint[-1]
        env_name = split_entrypoint[-1]

    v_path = os.path.join(
        os.path.dirname(__file__),
        "..",
        "envs",
        env_type,
        env_name + ".md",
    )

    front_matter = f"""---
autogenerated:
title: {title_env_name}
---
"""
    title = f"# {title_env_name}"
    gif = (
        "```{figure}"
        + f" ../../_static/videos/{env_type}/{env_name}.gif"
        + f" \n:width: 200px\n:name: {env_name}\n```"
    )
    all_text = f"""{front_matter}
{title}

{gif}

{docstring}
"""

    file = open(v_path, "w", encoding="utf-8")
    file.write(all_text)
    file.close()
